<!doctype html>
<html lang="uk">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Knowledge LLM — Чат</title>
    <style>
      :root { color-scheme: light dark; }
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 0; padding: 0; }
      header { padding: 12px 16px; border-bottom: 1px solid #8883; font-weight: 600; }
      main { display: grid; grid-template-rows: 1fr auto; height: calc(100dvh - 49px); }
      #chat { padding: 16px; overflow: auto; }
      .msg { margin: 8px 0; padding: 10px 12px; border-radius: 10px; max-width: 80ch; }
      .user { background: #2b7; color: #000; align-self: flex-end; }
      .assistant { background: #4445; }
      .system { background: #8883; font-style: italic; }
      .msg h1, .msg h2, .msg h3 { margin: .4em 0 .3em; }
      .msg pre { background: #0006; padding: 8px; border-radius: 6px; overflow: auto; }
      .msg code { background: #0004; padding: 1px 3px; border-radius: 4px; }
      .msg ul { margin: .3em 0 .3em 1.2em; }
      .row { display: flex; gap: 8px; align-items: center; padding: 8px; border-top: 1px solid #8883; }
      textarea { flex: 1; resize: vertical; min-height: 48px; max-height: 180px; padding: 8px; }
      button { padding: 10px 14px; font-weight: 600; }
      .muted { opacity: .7; font-size: .9em; }
      #status { padding: 0 12px; }
      .loading { display: inline-flex; align-items: center; gap: 8px; }
      .spinner { width: 14px; height: 14px; border: 2px solid #999; border-top-color: transparent; border-radius: 50%; animation: spin 1s linear infinite; }
      @keyframes spin { to { transform: rotate(360deg); } }
    </style>
  </head>
  <body>
    <header>
      Knowledge LLM — Чат (WebSocket)
      <span style="font-weight:400; margin-left:12px;">
        API URL:
        <input id="apiBaseInput" style="width:360px;" placeholder="https://api.example.com" />
        <button id="saveApiBtn">Зберегти</button>
        <span id="apiShow" class="muted"></span>
      </span>
    </header>
    <main style="grid-template-columns: 320px 1fr; grid-template-rows: 1fr auto auto; gap: 0;">
      <aside style="border-right:1px solid #8883; display:flex; flex-direction:column; overflow:auto;">
        <div style="padding:12px; border-bottom:1px solid #8883; font-weight:600;">Файли контексту</div>
        <div style="padding:12px; display:flex; flex-direction:column; gap:8px;">
          <input type="file" id="fileInput" multiple />
          <button id="uploadBtn">Завантажити</button>
          <button id="refreshFilesBtn">Оновити список</button>
          <div id="files" class="muted">(порожньо)</div>
        </div>
        <div style="padding:12px; border-top:1px solid #8883; font-weight:600;">Індекси</div>
        <div style="padding:12px; display:flex; flex-direction:column; gap:8px;">
          <div>Активний: <span id="activeIndex" class="muted">—</span></div>
          <button id="buildIndexBtn">Згенерувати індекс</button>
          <button id="refreshIndexesBtn">Оновити індекси</button>
          <div id="indexes" class="muted">(немає)</div>
        </div>
        <div style="padding:12px; border-top:1px solid #8883; font-weight:600;">Налаштування</div>
        <div style="padding:12px; display:flex; flex-direction:column; gap:8px;">
          <label>Режим:
            <select id="ragModeSel">
              <option value="auto">auto</option>
              <option value="rag_only">rag_only</option>
              <option value="llm_only">llm_only</option>
            </select>
          </label>
          <label>Top K:
            <input id="ragTopKInput" type="number" min="1" max="50" step="1" style="width:100px;" />
          </label>
          <label>Cutoff:
            <input id="ragCutoffInput" type="number" min="0" max="1" step="0.01" style="width:100px;" />
          </label>
          <label>Системний промпт:
            <textarea id="systemPromptInput" rows="6" placeholder="Опишіть роль і стиль асистента..." style="width:100%;"></textarea>
          </label>
          <div style="display:flex; gap:8px;">
            <button id="saveConfigBtn">Зберегти RAG</button>
            <button id="refreshConfigBtn">Оновити</button>
          </div>
          <div id="configInfo" class="muted"></div>
        </div>
      </aside>
      <div id="chat" style="grid-column: 2 / span 1; grid-row: 1 / span 1;"></div>
      <div class="row" style="grid-column: 2 / span 1; grid-row: 2 / span 1;">
        <textarea id="input" placeholder="Введіть питання та натисніть Надіслати..."></textarea>
        <button id="send">Надіслати</button>
        <span id="loadingIndicator" class="loading" style="display:none;"><span class="spinner"></span>Відповідаю…</span>
      </div>
      <div id="status" class="muted" style="grid-column: 1 / span 2; grid-row: 3 / span 1;"></div>
    </main>

    <script>
      const chatEl = document.getElementById('chat');
      const inputEl = document.getElementById('input');
      const sendBtn = document.getElementById('send');
      const statusEl = document.getElementById('status');
      const loadingIndicator = document.getElementById('loadingIndicator');

      // Full chat history that we will send with every ask
      // Each item: {role: 'user'|'assistant'|'system', content: string}
      let history = [];

      let ws;
      let connecting = false;
      // API base configuration
      function normalizeBase(s) {
        if (!s) return location.origin;
        try { s = s.trim(); } catch {}
        return s.replace(/\/+$/, '');
      }
      let apiBase = normalizeBase(localStorage.getItem('apiBase') || location.origin);

      function api(path) {
        if (!path.startsWith('/')) path = '/' + path;
        return apiBase + path;
      }

      function wsUrl() {
        try {
          const u = new URL(apiBase);
          u.protocol = (u.protocol === 'https:') ? 'wss:' : 'ws:';
          // Ensure single /ws at the end
          u.pathname = (u.pathname.replace(/\/+$/, '')) + '/ws';
          u.search = '';
          u.hash = '';
          return u.toString();
        } catch {
          const proto = (location.protocol === 'https:') ? 'wss:' : 'ws:';
          return proto + '//' + apiBase.replace(/^https?:\/\//, '') + '/ws';
        }
      }

      function ensureSocket() {
        if (ws && (ws.readyState === WebSocket.OPEN)) return Promise.resolve();
        if (connecting) return new Promise((res) => setTimeout(() => res(ensureSocket()), 100));
        connecting = true;
        return new Promise((resolve, reject) => {
          ws = new WebSocket(wsUrl());
          statusEl.textContent = 'Зʼєднання...';
          ws.onopen = () => { statusEl.textContent = 'Підключено'; connecting = false; resolve(); };
          ws.onclose = () => { statusEl.textContent = 'Відключено'; connecting = false; setLoading(false); };
          ws.onerror = (e) => { statusEl.textContent = 'Помилка вебсокету'; connecting = false; setLoading(false); reject(e); };
          ws.onmessage = onMessage;
        });
      }

      // --- Minimal Markdown renderer (safe) ---
      function mdEscape(s) {
        return s
          .replace(/&/g, '&amp;')
          .replace(/</g, '&lt;')
          .replace(/>/g, '&gt;');
      }

      function renderMarkdown(src) {
        let s = String(src || '');
        // Extract fenced code blocks first and keep placeholders
        const blocks = [];
        s = s.replace(/```([\s\S]*?)```/g, (_, code) => {
          blocks.push('<pre><code>' + mdEscape(code.trim()) + '</code></pre>');
          return `\u0000BLOCK${blocks.length-1}\u0000`;
        });
        // Headings
        s = s.replace(/^######\s+(.+)$/gm, '<h6>$1</h6>')
             .replace(/^#####\s+(.+)$/gm, '<h5>$1</h5>')
             .replace(/^####\s+(.+)$/gm, '<h4>$1</h4>')
             .replace(/^###\s+(.+)$/gm, '<h3>$1</h3>')
             .replace(/^##\s+(.+)$/gm, '<h2>$1</h2>')
             .replace(/^#\s+(.+)$/gm, '<h1>$1</h1>');
        // Lists (very small state machine)
        const lines = s.split(/\n/);
        let out = [];
        let inUl = false;
        for (let i = 0; i < lines.length; i++) {
          const m = lines[i].match(/^\s*[-*]\s+(.+)$/);
          if (m) {
            if (!inUl) { inUl = true; out.push('<ul>'); }
            out.push('<li>' + m[1] + '</li>');
          } else {
            if (inUl) { inUl = false; out.push('</ul>'); }
            out.push(lines[i]);
          }
        }
        if (inUl) out.push('</ul>');
        s = out.join('\n');
        // Escape remaining HTML
        s = s.replace(/&(?![a-zA-Z]+;|#\d+;)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;');
        // Inline code
        s = s.replace(/`([^`]+)`/g, (_, t) => '<code>' + t + '</code>');
        // Bold and italics (simple)
        s = s.replace(/\*\*([^*]+)\*\*/g, '<strong>$1</strong>');
        s = s.replace(/(^|[^*])\*([^*\n]+)\*/g, '$1<em>$2</em>');
        // Links
        s = s.replace(/\[([^\]]+)\]\((https?:[^\s)]+)\)/g, '<a href="$2" target="_blank" rel="noopener noreferrer">$1</a>');
        // Paragraph breaks
        s = s.replace(/\n\n+/g, '</p><p>');
        s = '<p>' + s + '</p>';
        // Reinsert code blocks
        s = s.replace(/\u0000BLOCK(\d+)\u0000/g, (_, i) => blocks[Number(i)] || '');
        return s;
      }

      // --- Very small HTML sanitizer with whitelist ---
      function sanitizeHTML(html) {
        const tpl = document.createElement('template');
        tpl.innerHTML = String(html || '');
        const ALLOWED = new Set(['A','P','BR','UL','OL','LI','STRONG','B','EM','I','CODE','PRE','H1','H2','H3','H4','H5','H6','DIV','SPAN']);
        const ALLOWED_ATTR = { A: new Set(['href','title','target','rel']) };
        const URL_ATTRS = new Set(['href']);
        const SAFE_PROTOCOLS = new Set(['http:','https:','mailto:']);
        const walker = (node) => {
          // Remove script/style/iframe completely
          if (node.nodeType === Node.ELEMENT_NODE) {
            const tag = node.tagName;
            if (!ALLOWED.has(tag)) {
              const txt = document.createTextNode(node.textContent || '');
              node.replaceWith(txt);
              return; // no deeper walk needed
            }
            // scrub attributes
            const allowedForTag = ALLOWED_ATTR[tag] || new Set();
            for (const attr of Array.from(node.attributes)) {
              const name = attr.name.toLowerCase();
              if (name.startsWith('on') || name === 'style') {
                node.removeAttribute(attr.name); continue;
              }
              if (!allowedForTag.has(attr.name)) {
                // Only a[href], etc. Others dropped
                if (!(tag === 'A' && allowedForTag.has('href') && name === 'href')) {
                  node.removeAttribute(attr.name); continue;
                }
              }
              if (URL_ATTRS.has(attr.name)) {
                try {
                  const url = new URL(attr.value, document.baseURI);
                  if (!SAFE_PROTOCOLS.has(url.protocol)) node.removeAttribute(attr.name);
                } catch { node.removeAttribute(attr.name); }
              }
            }
            // enforce safe defaults for links
            if (tag === 'A') {
              if (!node.getAttribute('rel')) node.setAttribute('rel','noopener noreferrer');
              if (!node.getAttribute('target')) node.setAttribute('target','_blank');
            }
          }
          for (const ch of Array.from(node.childNodes)) walker(ch);
        };
        for (const ch of Array.from(tpl.content.childNodes)) walker(ch);
        return tpl.innerHTML;
      }

      function isLikelyHTML(s) {
        return /<\s*(p|ul|ol|li|strong|em|b|i|h[1-6]|code|pre|br|a|div|span)(\s|>|\/)/i.test(String(s||''));
      }

      function renderRichText(src) {
        const s = String(src || '');
        if (isLikelyHTML(s)) return sanitizeHTML(s);
        return renderMarkdown(s);
      }

      function addMessage(role, content) {
        const div = document.createElement('div');
        div.className = 'msg ' + role;
        if (role === 'assistant' || role === 'system') {
          div.innerHTML = renderRichText(content);
        } else {
          div.textContent = content;
        }
        chatEl.appendChild(div);
        chatEl.scrollTop = chatEl.scrollHeight;
        return div; // return node for streaming updates
      }

      let streamingNode = null;
      let streamingBuffer = '';
      let isLoading = false;

      function setLoading(v) {
        isLoading = !!v;
        inputEl.disabled = isLoading;
        sendBtn.disabled = isLoading;
        loadingIndicator.style.display = isLoading ? 'inline-flex' : 'none';
        if (!isLoading) inputEl.focus();
      }

      function onMessage(ev) {
        // Only attempt to parse JSON frames; ignore non-JSON
        const text = typeof ev.data === 'string' ? ev.data.trim() : '';
        if (!text || (text[0] !== '{' && text[0] !== '[')) {
          console.debug('Non-JSON WS frame ignored:', ev.data);
          return;
        }
        try {
          const data = JSON.parse(text);
          if (data.type === 'token') {
            if (!streamingNode) streamingNode = addMessage('assistant', '');
            streamingBuffer += data.token;
            streamingNode.innerHTML = renderRichText(streamingBuffer);
          } else if (data.type === 'ready') {
            // handshake message
            statusEl.textContent = 'Підключено';
          } else if (data.type === 'done') {
            // Finalize assistant message
            history = data.history || history;
            streamingNode = null;
            streamingBuffer = '';
            setLoading(false);
          } else if (data.type === 'error') {
            addMessage('system', 'Помилка: ' + data.error);
            streamingNode = null;
            streamingBuffer = '';
            setLoading(false);
          }
        } catch (e) {
          console.warn('WS JSON parse error', e);
        }
      }

      async function sendMessage() {
        if (isLoading) return; // prevent parallel sends
        const text = inputEl.value.trim();
        if (!text) return;
        inputEl.value = '';
        addMessage('user', text);
        history.push({ role: 'user', content: text });

        try {
          setLoading(true);
          await ensureSocket();
          ws.send(JSON.stringify({ type: 'ask', message: text, history }));
        } catch (e) {
          addMessage('system', 'Не вдалося підключитись до сервера');
          setLoading(false);
        }
      }

      inputEl.addEventListener('keydown', (e) => {
        if ((e.key === 'Enter' && !e.shiftKey)) {
          e.preventDefault();
          sendMessage();
        }
      });
      sendBtn.addEventListener('click', sendMessage);

      // ------ Files UI ------
      const filesEl = document.getElementById('files');
      const fileInput = document.getElementById('fileInput');
      const uploadBtn = document.getElementById('uploadBtn');
      const refreshFilesBtn = document.getElementById('refreshFilesBtn');

      async function refreshFiles() {
        const res = await fetch(api('/files'));
        const data = await res.json();
        if (!data.files || !data.files.length) {
          filesEl.textContent = '(порожньо)';
          return;
        }
        filesEl.innerHTML = '';
        for (const f of data.files) {
          const div = document.createElement('div');
          const sizeKB = Math.round((f.size || 0) / 102.4) / 10;
          const dt = new Date((f.mtime || 0) * 1000).toLocaleString();
          div.textContent = `${f.name} — ${sizeKB} KB — ${dt}`;
          filesEl.appendChild(div);
        }
      }

      async function uploadFiles() {
        const files = fileInput.files;
        if (!files || files.length === 0) return;
        for (const f of files) {
          const fd = new FormData();
          fd.append('file', f);
          const res = await fetch(api('/upload'), { method: 'POST', body: fd });
          if (!res.ok) {
            addMessage('system', `Не вдалося завантажити ${f.name}`);
          }
        }
        await refreshFiles();
      }

      uploadBtn.addEventListener('click', uploadFiles);
      refreshFilesBtn.addEventListener('click', refreshFiles);

      // ------ Indexes UI ------
      const indexesEl = document.getElementById('indexes');
      const activeIndexEl = document.getElementById('activeIndex');
      const buildIndexBtn = document.getElementById('buildIndexBtn');
      const refreshIndexesBtn = document.getElementById('refreshIndexesBtn');
      // Config UI
      const ragModeSel = document.getElementById('ragModeSel');
      const ragTopKInput = document.getElementById('ragTopKInput');
      const ragCutoffInput = document.getElementById('ragCutoffInput');
      const systemPromptInput = document.getElementById('systemPromptInput');
      const saveConfigBtn = document.getElementById('saveConfigBtn');
      const refreshConfigBtn = document.getElementById('refreshConfigBtn');
      const configInfo = document.getElementById('configInfo');

      async function refreshIndexes() {
        const res = await fetch(api('/index/list'));
        const data = await res.json();
        activeIndexEl.textContent = data.active || '—';
        const items = data.items || [];
        if (!items.length) {
          indexesEl.textContent = '(немає)';
          return;
        }
        indexesEl.innerHTML = '';
        for (const it of items) {
          const row = document.createElement('div');
          const dt = new Date((it.mtime || 0) * 1000).toLocaleString();
          row.style.display = 'flex';
          row.style.alignItems = 'center';
          row.style.gap = '8px';
          const span = document.createElement('span');
          span.textContent = `${it.id} — ${dt}`;
          const btn = document.createElement('button');
          btn.textContent = 'Застосувати';
          btn.onclick = async () => {
            await fetch(api('/index/apply'), { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify({ index_id: it.id }) });
            await refreshIndexes();
          };
          row.appendChild(span);
          row.appendChild(btn);
          indexesEl.appendChild(row);
        }
      }

      async function buildIndex() {
        const res = await fetch(api('/index/build'), { method: 'POST' });
        if (res.ok) {
          addMessage('system', 'Індекс згенеровано');
          await refreshIndexes();
        } else {
          addMessage('system', 'Помилка генерації індексу');
        }
      }

      buildIndexBtn.addEventListener('click', buildIndex);
      refreshIndexesBtn.addEventListener('click', refreshIndexes);
      
      // ------ Config UI ------
      async function refreshConfig() {
        try {
          const res = await fetch(api('/config'));
          if (!res.ok) throw new Error('HTTP ' + res.status);
          const data = await res.json();
          ragModeSel.value = data.rag_mode || 'auto';
          ragTopKInput.value = data.rag_top_k != null ? data.rag_top_k : 4;
          ragCutoffInput.value = data.rag_cutoff != null ? data.rag_cutoff : 0.3;
          systemPromptInput.value = data.system_prompt || '';
          configInfo.textContent = `mode=${ragModeSel.value}, topK=${ragTopKInput.value}, cutoff=${ragCutoffInput.value}`;
        } catch (e) {
          configInfo.textContent = 'Не вдалося отримати конфіг';
        }
      }

      async function saveConfig() {
        const body = {
          rag_mode: ragModeSel.value,
          rag_top_k: Number(ragTopKInput.value || 4),
          rag_cutoff: Number(ragCutoffInput.value || 0.3),
          system_prompt: systemPromptInput.value,
        };
        try {
          const res = await fetch(api('/config'), {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(body),
          });
          if (!res.ok) {
            const txt = await res.text().catch(()=> '');
            throw new Error('HTTP ' + res.status + ' ' + txt);
          }
          const data = await res.json();
          ragModeSel.value = data.rag_mode || 'auto';
          ragTopKInput.value = data.rag_top_k != null ? data.rag_top_k : 4;
          ragCutoffInput.value = data.rag_cutoff != null ? data.rag_cutoff : 0.3;
          systemPromptInput.value = data.system_prompt || '';
          configInfo.textContent = `Збережено: mode=${data.rag_mode}, topK=${data.rag_top_k}, cutoff=${data.rag_cutoff}`;
          addMessage('system', 'Налаштування збережено');
        } catch (e) {
          addMessage('system', 'Помилка збереження налаштувань: ' + e.message);
        }
      }

      saveConfigBtn.addEventListener('click', saveConfig);
      refreshConfigBtn.addEventListener('click', refreshConfig);

      // API base UI wiring
      const apiBaseInput = document.getElementById('apiBaseInput');
      const saveApiBtn = document.getElementById('saveApiBtn');
      const apiShow = document.getElementById('apiShow');
      function updateApiUI() {
        apiBaseInput.value = apiBase;
        apiShow.textContent = apiBase;
      }
      updateApiUI();
      saveApiBtn.addEventListener('click', async () => {
        apiBase = normalizeBase(apiBaseInput.value || '');
        localStorage.setItem('apiBase', apiBase);
        updateApiUI();
        try { ws && ws.close && ws.close(); } catch {}
        ws = null; connecting = false; streamingNode = null; streamingBuffer = '';
        await refreshFiles();
        await refreshIndexes();
        await refreshConfig();
      });

      // Initial loads
      refreshFiles();
      refreshIndexes();
      refreshConfig();
    </script>
  </body>
  </html>
